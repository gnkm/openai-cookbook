# PLANS.mdを使用した数時間にわたる問題解決

Codexと`gpt-5.2-codex`モデル（推奨）は、研究、設計、実装に相当な時間を要する複雑なタスクを実装するために使用できます。ここで説明するアプローチは、モデルにこれらのタスクを実装させ、プロジェクトの成功完了に向けて導く一つの方法です。

これらの計画は徹底的な設計文書であり、「生きた文書」です。Codexのユーザーとして、これらの文書を使用して、Codexが長時間の実装プロセスを開始する前に、Codexが取るアプローチを検証することができます。以下に含まれる特定の`PLANS.md`は、Codexが単一のプロンプトから7時間以上作業することを可能にしたものと非常に似ています。

これらの文書をCodexが使用できるようにするため、まず`AGENTS.md`を更新して`PLANS.md`をいつ使用するかを記述し、その後もちろん`PLANS.md`ファイルをリポジトリに追加します。

## `AGENTS.md`

[`AGENTS.md`](https://github.com/openai/agents.md)は、Codexなどのコーディングエージェントを導くためのシンプルな形式です。ユーザーが略語として使用できる用語と、計画文書をいつ使用するかの簡単なルールを記述します。ここでは、これを「ExecPlan」と呼びます。これは任意の用語であり、Codexはこれについて訓練されていないことに注意してください。この略語は、Codexにプロンプトを与える際に、計画の特定の定義に導くために使用できます。

以下は、エージェントに計画をいつ使用するかを指示する`AGENTS.md`のセクションです：

```md
# ExecPlans

複雑な機能や大幅なリファクタリングを書く際は、設計から実装まで（.agent/PLANS.mdで説明されている）ExecPlanを使用してください。
```

## `PLANS.md`

以下が文書全体です。この文書のプロンプトは、ユーザーに大量のフィードバックを提供し、計画が指定する内容を正確に実装するようモデルを導くために慎重に選択されました。ユーザーは、ニーズに合わせてファイルをカスタマイズしたり、必要なセクションを追加または削除したりすることで恩恵を受ける可能性があります。

````md
# Codex実行計画（ExecPlans）：

この文書は、コーディングエージェントが動作する機能やシステム変更を提供するために従うことができる設計文書である実行計画（「ExecPlan」）の要件を記述します。読者をこのリポジトリの完全な初心者として扱ってください：彼らは現在の作業ツリーとあなたが提供する単一のExecPlanファイルのみを持っています。以前の計画の記憶も外部コンテキストもありません。

## ExecPlansとPLANS.mdの使用方法

実行可能仕様（ExecPlan）を作成する際は、PLANS.mdに_文字通り_従ってください。それがコンテキストにない場合は、PLANS.mdファイル全体を読んで記憶を更新してください。正確な仕様を作成するために、ソース資料を徹底的に読み（そして再読し）てください。仕様を作成する際は、スケルトンから始めて、研究を行いながら詳細を肉付けしてください。

実行可能仕様（ExecPlan）を実装する際は、ユーザーに「次のステップ」を求めず、単純に次のマイルストーンに進んでください。すべてのセクションを最新に保ち、停止ポイントごとにリストのエントリを追加または分割して、行われた進捗と次のステップを明確に述べてください。曖昧さを自律的に解決し、頻繁にコミットしてください。

実行可能仕様（ExecPlan）について議論する際は、後世のために仕様のログに決定を記録してください；仕様への変更がなぜ行われたかが明確でなければなりません。ExecPlansは生きた文書であり、_ExecPlanのみ_から他の作業なしに常に再開できるべきです。

困難な要件や重要な未知数を持つ設計を研究する際は、マイルストーンを使用して概念実証、「おもちゃの実装」などを実装し、ユーザーの提案が実現可能かどうかを検証できるようにしてください。ライブラリを見つけたり取得したりしてそのソースコードを読み、深く研究し、より完全な実装を導くプロトタイプを含めてください。

## 要件

交渉不可能な要件：

* すべてのExecPlanは完全に自己完結している必要があります。自己完結とは、現在の形で初心者が成功するために必要なすべての知識と指示を含んでいることを意味します。
* すべてのExecPlanは生きた文書です。貢献者は、進捗が行われ、発見が起こり、設計決定が確定するにつれて、それを修正する必要があります。各修正は完全に自己完結したままでなければなりません。
* すべてのExecPlanは、完全な初心者がこのリポジトリの事前知識なしに機能をエンドツーエンドで実装できるようにする必要があります。
* すべてのExecPlanは、単に「定義を満たす」コード変更ではなく、実証可能に動作する振る舞いを生成する必要があります。
* すべてのExecPlanは、すべての専門用語を平易な言葉で定義するか、使用しないでください。

目的と意図が最優先です。まず、ユーザーの視点から作業がなぜ重要かを数文で説明することから始めてください：この変更後に誰かができるようになることで、以前はできなかったこと、そしてそれが動作しているのを見る方法。その後、何を編集し、何を実行し、何を観察すべきかを含めて、その結果を達成するための正確なステップを読者に案内してください。

あなたの計画を実行するエージェントは、ファイルのリスト表示、ファイルの読み取り、検索、プロジェクトの実行、テストの実行ができます。事前のコンテキストを知らず、以前のマイルストーンから何を意味したかを推測できません。依存する仮定を繰り返してください。外部のブログや文書を指さないでください；知識が必要な場合は、あなた自身の言葉で計画自体に埋め込んでください。ExecPlanが以前のExecPlanに基づいており、そのファイルがチェックインされている場合は、参照によってそれを組み込んでください。そうでない場合は、その計画からのすべての関連コンテキストを含める必要があります。

## フォーマット

フォーマットとエンベロープはシンプルで厳格です。各ExecPlanは、三重バッククォートで始まり終わる`md`とラベル付けされた単一のフェンスされたコードブロックでなければなりません。内部に追加の三重バッククォートコードフェンスをネストしないでください；コマンド、トランスクリプト、差分、またはコードを表示する必要がある場合は、その単一のフェンス内でインデントされたブロックとして提示してください。ExecPlanのコードフェンスを早期に閉じることを避けるために、ExecPlan内でコードフェンスの代わりにインデントを明確性のために使用してください。すべての見出しの後に2つの改行を使用し、#と##などを使用し、順序付きおよび順序なしリストの正しい構文を使用してください。

コンテンツが_単一のExecPlanのみ_であるMarkdown（.md）ファイルにExecPlanを書く場合は、三重バッククォートを省略する必要があります。

平易な散文で書いてください。リストよりも文を好んでください。簡潔さが意味を曖昧にしない限り、チェックリスト、表、長い列挙を避けてください。チェックリストは`Progress`セクションでのみ許可され、そこでは必須です。物語セクションは散文優先のままでなければなりません。

## ガイドライン

自己完結性と平易な言葉が最重要です。普通の英語ではない語句（「daemon」、「middleware」、「RPCゲートウェイ」、「フィルターグラフ」）を導入する場合は、即座に定義し、このリポジトリでそれがどのように現れるかを読者に思い出させてください（例えば、それが現れるファイルやコマンドを名前で示すことによって）。「以前に定義された通り」や「アーキテクチャ文書によると」と言わないでください。自分自身を繰り返すことになっても、必要な説明をここに含めてください。

一般的な失敗モードを避けてください。未定義の専門用語に依存しないでください。「機能の文字通り」をコンパイルはするが意味のあることは何もしないほど狭く記述しないでください。重要な決定を読者に外注しないでください。曖昧さが存在する場合は、計画自体でそれを解決し、なぜその道を選んだかを説明してください。ユーザーに見える効果を過度に説明し、付随的な実装詳細を過少に指定する側に誤ってください。

観察可能な結果で計画を固定してください。実装後にユーザーができること、実行するコマンド、見るべき出力を述べてください。受け入れは、内部属性（「HealthCheck構造体を追加した」）ではなく、人間が検証できる振る舞い（「サーバーを起動した後、[http://localhost:8080/health](http://localhost:8080/health)にナビゲートするとHTTP 200とボディOKが返される」）として表現されるべきです。変更が内部的な場合は、その影響をどのように実証できるかを説明してください（例えば、変更前に失敗し変更後に成功するテストを実行することによって、そして新しい振る舞いを使用するシナリオを示すことによって）。

リポジトリコンテキストを明示的に指定してください。完全なリポジトリ相対パスでファイルを名前付けし、関数とモジュールを正確に名前付けし、新しいファイルをどこに作成すべきかを記述してください。複数の領域に触れる場合は、初心者が自信を持ってナビゲートできるように、それらの部分がどのように組み合わさるかを説明する短いオリエンテーション段落を含めてください。コマンドを実行する際は、作業ディレクトリと正確なコマンドラインを示してください。結果が環境に依存する場合は、仮定を述べ、合理的な場合は代替案を提供してください。

冪等で安全であってください。損害やドリフトを引き起こすことなく複数回実行できるようにステップを書いてください。ステップが途中で失敗する可能性がある場合は、再試行や適応の方法を含めてください。移行や破壊的操作が必要な場合は、バックアップや安全なフォールバックを詳しく説明してください。進行中に検証できる追加的でテスト可能な変更を好んでください。

検証は任意ではありません。テストを実行し、該当する場合はシステムを起動し、何か有用なことをしているのを観察する指示を含めてください。新しい機能や能力の包括的なテストを記述してください。初心者が成功と失敗を区別できるように、期待される出力とエラーメッセージを含めてください。可能な場合は、コンパイル以上に変更が効果的であることを証明する方法を示してください（例えば、小さなエンドツーエンドシナリオ、CLI呼び出し、またはHTTPリクエスト/レスポンストランスクリプトを通じて）。プロジェクトのツールチェーンに適した正確なテストコマンドとその結果の解釈方法を述べてください。

証拠を捕捉してください。ステップがターミナル出力、短い差分、またはログを生成する場合は、単一のフェンスされたブロック内にインデントされた例としてそれらを含めてください。成功を証明することに焦点を当てて簡潔に保ってください。パッチを含める必要がある場合は、大きなブロブを貼り付けるのではなく、読者があなたの指示に従って再作成できるファイルスコープの差分や小さな抜粋を好んでください。

## マイルストーン

マイルストーンは物語であり、官僚主義ではありません。作業をマイルストーンに分割する場合は、範囲、マイルストーンの終わりに以前は存在しなかったが存在するもの、実行するコマンド、観察することを期待する受け入れを記述する簡潔な段落で各マイルストーンを導入してください。ストーリーとして読みやすく保ってください：目標、作業、結果、証明。進捗とマイルストーンは異なります：マイルストーンはストーリーを語り、進捗は詳細な作業を追跡します。両方が存在しなければなりません。簡潔さのためだけにマイルストーンを省略せず、将来の実装に重要である可能性のある詳細を省かないでください。

各マイルストーンは独立して検証可能で、実行計画の全体的な目標を段階的に実装する必要があります。

## 生きた計画と設計決定

* ExecPlansは生きた文書です。重要な設計決定を行う際は、決定とその背後にある思考の両方を記録するために計画を更新してください。すべての決定を`Decision Log`セクションに記録してください。
* ExecPlansは`Progress`セクション、`Surprises & Discoveries`セクション、`Decision Log`、`Outcomes & Retrospective`セクションを含み、維持しなければなりません。これらは任意ではありません。
* オプティマイザーの振る舞い、パフォーマンストレードオフ、予期しないバグ、またはあなたのアプローチを形作った逆/適用解除セマンティクスを発見した場合は、短い証拠スニペット（テスト出力が理想的）とともにそれらの観察を`Surprises & Discoveries`セクションに捕捉してください。
* 実装の途中でコースを変更する場合は、`Decision Log`でその理由を文書化し、`Progress`に影響を反映してください。計画は、あなたのためのチェックリストと同じくらい次の貢献者のためのガイドです。
* 主要なタスクまたは完全な計画の完了時に、達成されたこと、残っていること、学んだ教訓を要約する`Outcomes & Retrospective`エントリを書いてください。

# プロトタイピングマイルストーンと並行実装

より大きな変更のリスクを軽減する場合、明示的なプロトタイピングマイルストーンを含めることは受け入れられ、しばしば推奨されます。例：実現可能性を検証するために依存関係に低レベル演算子を追加する、またはオプティマイザー効果を測定しながら2つの構成順序を探索する。プロトタイプを追加的でテスト可能に保ってください。範囲を「プロトタイピング」として明確にラベル付けし；実行と結果の観察方法を記述し；プロトタイプを昇格または破棄する基準を述べてください。

テストが合格し続ける減算が続く追加的なコード変更を好んでください。並行実装（例えば、大規模な移行中に古いパスと一緒にアダプターを保持する）は、リスクを軽減したり、大規模な移行中にテストが合格し続けることを可能にする場合は問題ありません。両方のパスを検証する方法と、テストで一方を安全に廃止する方法を記述してください。複数の新しいライブラリや機能領域で作業する場合は、これらの機能の実現可能性を_互いに独立して_評価するスパイクを作成することを検討し、外部ライブラリが期待通りに動作し、必要な機能を単独で実装することを証明してください。

## 良いExecPlanのスケルトン

```md
# <短い、行動指向の記述>

このExecPlanは生きた文書です。`Progress`、`Surprises & Discoveries`、`Decision Log`、`Outcomes & Retrospective`のセクションは、作業が進むにつれて最新に保たれなければなりません。

PLANS.mdファイルがリポジトリにチェックインされている場合は、リポジトリルートからそのファイルへのパスをここで参照し、この文書がPLANS.mdに従って維持されなければならないことを注記してください。

## 目的 / 全体像

この変更後に誰かが得るものと、それが動作しているのを見る方法を数文で説明してください。有効にするユーザーに見える振る舞いを述べてください。

## 進捗

チェックボックス付きのリストを使用して詳細なステップを要約してください。すべての停止ポイントは、部分的に完了したタスクを2つに分割する（「完了」対「残り」）必要がある場合でも、ここに文書化されなければなりません。このセクションは常に作業の実際の現在状態を反映しなければなりません。

- [x] (2025-10-01 13:00Z) 完了したステップの例。
- [ ] 未完了のステップの例。
- [ ] 部分的に完了したステップの例（完了：X；残り：Y）。

進捗率を測定するためにタイムスタンプを使用してください。

## 驚きと発見

実装中に発見された予期しない振る舞い、バグ、最適化、または洞察を文書化してください。簡潔な証拠を提供してください。

- 観察：…
  証拠：…

## 決定ログ

計画で作業中に行われたすべての決定を以下の形式で記録してください：

- 決定：…
  根拠：…
  日付/著者：…

## 結果と振り返り

主要なマイルストーンまたは完了時に、結果、ギャップ、学んだ教訓を要約してください。結果を元の目的と比較してください。

## コンテキストとオリエンテーション

読者が何も知らないかのように、このタスクに関連する現在の状態を記述してください。完全パスで主要なファイルとモジュールを名前付けしてください。使用する自明でない用語を定義してください。以前の計画を参照しないでください。

## 作業計画

編集と追加のシーケンスを散文で記述してください。各編集について、ファイルと場所（関数、モジュール）を名前付けし、何を挿入または変更するかを述べてください。具体的で最小限に保ってください。

## 具体的なステップ

実行する正確なコマンドとそれらを実行する場所（作業ディレクトリ）を述べてください。コマンドが出力を生成する場合は、読者が比較できるように短い期待されるトランスクリプトを示してください。このセクションは作業が進むにつれて更新されなければなりません。

## 検証と受け入れ

システムを起動または実行する方法と何を観察するかを記述してください。特定の入力と出力で、受け入れを振る舞いとして表現してください。テストが関与する場合は、「<プロジェクトのテストコマンド>を実行し、<N>個の合格を期待；新しいテスト<名前>は変更前に失敗し変更後に合格する」と言ってください。

## 冪等性と回復

ステップが安全に繰り返せる場合は、そう言ってください。ステップがリスクを伴う場合は、安全な再試行またはロールバックパスを提供してください。完了後に環境をクリーンに保ってください。

## アーティファクトとメモ

成功を証明する最も重要なトランスクリプト、差分、またはスニペットをインデントされた例として含めてください。簡潔で成功を証明することに焦点を当てて保ってください。

## インターフェースと依存関係

規範的であってください。使用するライブラリ、モジュール、サービスとその理由を名前付けしてください。マイルストーンの終わりに存在しなければならない型、トレイト/インターフェース、関数シグネチャを指定してください。`crate::module::function`や`package.submodule.Interface`などの安定した名前とパスを好んでください。例：

crates/foo/planner.rsで、以下を定義：

    pub trait Planner {
        fn plan(&self, observed: &Observed) -> Vec<Action>;
    }
```

上記のガイダンスに従えば、単一のステートレスエージェント、または人間の初心者が、あなたのExecPlanを上から下まで読んで、動作する観察可能な結果を生成できます。それが基準です：自己完結、自己充足、初心者ガイド、結果重視。

計画を修正する際は、生きた文書セクションを含むすべてのセクションに変更が包括的に反映されることを確認し、計画の下部に変更とその理由を記述するメモを書かなければなりません。ExecPlansは何をするかだけでなく、ほぼすべてについてなぜそうするかを記述しなければなりません。
````