# 複数時間の問題解決のための PLANS.md の使用

Codex と `gpt-5.2-codex` モデル（推奨）は、調査、設計、実装に多大な時間を要する複雑なタスクを実装するために使用できます。ここで説明するアプローチは、これらのタスクを実装するようモデルにプロンプトを与え、プロジェクトの成功に向けて導く一つの方法です。

これらの計画は徹底的な設計ドキュメントであり、「生きたドキュメント」です。Codex のユーザーとして、これらのドキュメントを使用して、Codex が長い実装プロセスを開始する前に取るアプローチを検証できます。以下に含まれる特定の `PLANS.md` は、Codex が単一のプロンプトから7時間以上作業することを可能にしたものと非常に似ています。

Codex がこれらのドキュメントを使用できるようにするには、まず `AGENTS.md` を更新して `PLANS.md` を使用するタイミングを記述し、次にもちろん `PLANS.md` ファイルをリポジトリに追加します。

## `AGENTS.md`

[`AGENTS.md`](https://github.com/openai/agents.md) は、Codex などのコーディングエージェントをガイドするためのシンプルなフォーマットです。ユーザーが省略表現として使用できる用語と、計画ドキュメントを使用するタイミングに関するシンプルなルールを記述します。ここでは、これを「ExecPlan」と呼びます。これは任意の用語であり、Codex はこれについて訓練されていないことに注意してください。この省略表現は、Codex にプロンプトを与える際に使用して、計画の特定の定義に導くことができます。

以下は、エージェントに計画を使用するタイミングを指示する `AGENTS.md` セクションです：

```md
# ExecPlans

複雑な機能や大規模なリファクタリングを作成する場合は、設計から実装まで ExecPlan（.agent/PLANS.md に記述されている）を使用してください。
```

## `PLANS.md`

以下はドキュメント全体です。このドキュメントのプロンプトは、ユーザーに大量のフィードバックを提供し、計画が指定する内容を正確に実装するようモデルをガイドするために慎重に選択されました。ユーザーは、ニーズに合わせてファイルをカスタマイズしたり、必要なセクションを追加または削除したりすることで利益を得る可能性があります。

````md
# Codex 実行計画（ExecPlans）：

このドキュメントは、コーディングエージェントが従って機能やシステム変更を提供できる設計ドキュメントである実行計画（「ExecPlan」）の要件を説明します。読者をこのリポジトリの完全な初心者として扱ってください：彼らは現在の作業ツリーとあなたが提供する単一の ExecPlan ファイルのみを持っています。以前の計画の記憶も外部コンテキストもありません。

## ExecPlans と PLANS.md の使用方法

実行可能な仕様（ExecPlan）を作成する際は、PLANS.md に_文字通り_従ってください。コンテキストにない場合は、PLANS.md ファイル全体を読んで記憶を更新してください。正確な仕様を作成するために、ソース資料を徹底的に読み（再読み）してください。仕様を作成する際は、スケルトンから始めて、調査を進めながら肉付けしてください。

実行可能な仕様（ExecPlan）を実装する際は、ユーザーに「次のステップ」を促さないでください。単純に次のマイルストーンに進んでください。すべてのセクションを最新の状態に保ち、停止ポイントごとにリスト内のエントリを追加または分割して、進捗状況と次のステップを明確に示してください。曖昧さを自律的に解決し、頻繁にコミットしてください。

実行可能な仕様（ExecPlan）について議論する際は、決定をログに記録して後世に残してください。仕様への変更がなぜ行われたのかが明確にわかるようにする必要があります。ExecPlans は生きたドキュメントであり、_ExecPlan のみ_から、他の作業なしで常に再開できるようにする必要があります。

困難な要件や重大な未知数を含む設計を調査する際は、マイルストーンを使用して概念実証、「トイ実装」などを実装し、ユーザーの提案が実現可能かどうかを検証できるようにしてください。ライブラリを見つけるか入手してソースコードを読み、深く調査し、プロトタイプを含めてより完全な実装をガイドしてください。

## 要件

譲れない要件：

* すべての ExecPlan は完全に自己完結している必要があります。自己完結とは、現在の形式で、初心者が成功するために必要なすべての知識と指示が含まれていることを意味します。
* すべての ExecPlan は生きたドキュメントです。貢献者は、進捗があった際、発見があった際、設計決定が確定した際に、それを修正する必要があります。各修正は完全に自己完結したままでなければなりません。
* すべての ExecPlan は、完全な初心者がこのリポジトリの事前知識なしに機能をエンドツーエンドで実装できるようにする必要があります。
* すべての ExecPlan は、単に「定義を満たす」コード変更ではなく、実証可能に機能する動作を生成する必要があります。
* すべての ExecPlan は、すべての専門用語を平易な言葉で定義するか、使用しないでください。

目的と意図が最優先です。まず、ユーザーの視点から作業が重要である理由を数文で説明します：この変更後に、以前はできなかったことができるようになり、それが機能しているのをどのように確認できるか。次に、何を編集し、何を実行し、何を観察すべきかを含め、その結果を達成するための正確なステップを読者に案内します。

計画を実行するエージェントは、ファイルのリスト表示、ファイルの読み取り、検索、プロジェクトの実行、テストの実行ができます。事前のコンテキストを知らず、以前のマイルストーンから意図したことを推測できません。依拠する仮定を繰り返してください。外部のブログやドキュメントを指さないでください。知識が必要な場合は、計画自体に自分の言葉で埋め込んでください。ExecPlan が以前の ExecPlan の上に構築され、そのファイルがチェックインされている場合は、参照によって組み込んでください。そうでない場合は、その計画からすべての関連コンテキストを含める必要があります。

## フォーマット

フォーマットとエンベロープはシンプルで厳格です。各 ExecPlan は、`md` とラベル付けされた単一のフェンスされたコードブロックで、トリプルバッククォートで始まり、終わる必要があります。内部に追加のトリプルバッククォートコードフェンスをネストしないでください。コマンド、トランスクリプト、差分、コードを表示する必要がある場合は、その単一のフェンス内でインデントされたブロックとして表示してください。ExecPlan のコードフェンスを早期に閉じないように、ExecPlan 内でコードフェンスの代わりにインデントを使用してください。すべての見出しの後に2つの改行を使用し、# と ## などを使用し、順序付きリストと順序なしリストの正しい構文を使用してください。

ExecPlan を Markdown（.md）ファイルに書き込む場合、ファイルの内容が_単一の_ ExecPlan _のみ_である場合は、トリプルバッククォートを省略する必要があります。

平易な散文で書いてください。リストよりも文章を優先してください。簡潔さが意味を曖昧にする場合を除き、チェックリスト、テーブル、長い列挙を避けてください。チェックリストは `Progress` セクションでのみ許可され、そこでは必須です。ナラティブセクションは散文優先のままでなければなりません。

## ガイドライン

自己完結性と平易な言語が最も重要です。通常の英語ではないフレーズ（「デーモン」、「ミドルウェア」、「RPC ゲートウェイ」、「フィルターグラフ」）を導入する場合は、すぐに定義し、このリポジトリでどのように現れるかを読者に思い出させてください（たとえば、それが現れるファイルやコマンドを名前で指定することによって）。「前に定義したように」や「アーキテクチャドキュメントによると」と言わないでください。必要な説明をここに含めてください。自分自身を繰り返す場合でも。

一般的な失敗モードを避けてください。未定義の専門用語に依存しないでください。「機能の文字通り」を狭く記述して、結果のコードがコンパイルされるが意味のあることをしないようにしないでください。重要な決定を読者にアウトソースしないでください。曖昧さが存在する場合は、計画自体で解決し、そのパスを選択した理由を説明してください。ユーザーに見える効果を過度に説明し、付随的な実装の詳細を過小に指定する方向に誤ってください。

計画を観察可能な結果で固定してください。実装後にユーザーができること、実行するコマンド、表示される出力を記述してください。受け入れは、人間が検証できる動作（「サーバーを起動した後、[http://localhost:8080/health](http://localhost:8080/health) に移動すると、本文 OK で HTTP 200 が返される」）として表現されるべきであり、内部属性（「HealthCheck 構造体を追加した」）として表現されるべきではありません。変更が内部的なものである場合は、その影響をどのように実証できるかを説明してください（たとえば、前は失敗し、後は成功するテストを実行し、新しい動作を使用するシナリオを示すことによって）。

リポジトリコンテキストを明示的に指定してください。完全なリポジトリ相対パスでファイルに名前を付け、関数とモジュールに正確に名前を付け、新しいファイルを作成する場所を説明してください。複数の領域に触れる場合は、それらの部分がどのように組み合わさるかを説明する短いオリエンテーションの段落を含めて、初心者が自信を持ってナビゲートできるようにしてください。コマンドを実行する際は、作業ディレクトリと正確なコマンドラインを表示してください。結果が環境に依存する場合は、仮定を述べ、合理的な場合は代替案を提供してください。

冪等で安全であってください。ステップを複数回実行しても、損傷やドリフトを引き起こさないように記述してください。ステップが途中で失敗する可能性がある場合は、再試行または適応する方法を含めてください。移行または破壊的な操作が必要な場合は、バックアップまたは安全なフォールバックを詳しく説明してください。進行中に検証できる、追加的でテスト可能な変更を優先してください。

検証はオプションではありません。テストを実行し、該当する場合はシステムを起動し、有用なことをしているのを観察する手順を含めてください。新しい機能や能力について包括的なテストを説明してください。初心者が成功と失敗を区別できるように、期待される出力とエラーメッセージを含めてください。可能な場合は、コンパイルを超えて変更が効果的であることを証明する方法を示してください（たとえば、小さなエンドツーエンドのシナリオ、CLI 呼び出し、HTTP リクエスト/レスポンストランスクリプトを通じて）。プロジェクトのツールチェーンに適した正確なテストコマンドと、その結果を解釈する方法を記述してください。

証拠をキャプチャしてください。ステップがターミナル出力、短い差分、ログを生成する場合は、単一のフェンスされたブロック内にインデントされた例としてそれらを含めてください。成功を証明するものに焦点を当てて、簡潔に保ってください。パッチを含める必要がある場合は、大きなブロブを貼り付けるのではなく、読者が指示に従って再作成できるファイルスコープの差分または小さな抜粋を優先してください。

## マイルストーン

マイルストーンは官僚主義ではなく、ナラティブです。作業をマイルストーンに分割する場合は、各マイルストーンを簡単な段落で紹介し、スコープ、マイルストーンの終わりに以前には存在しなかったもの、実行するコマンド、観察することを期待する受け入れを説明します。ストーリーとして読みやすく保ちます：目標、作業、結果、証明。進捗状況とマイルストーンは異なります：マイルストーンはストーリーを語り、進捗状況は粒度の細かい作業を追跡します。両方が存在する必要があります。簡潔さのためだけにマイルストーンを省略しないでください。将来の実装に重要である可能性のある詳細を除外しないでください。

各マイルストーンは独立して検証可能であり、実行計画の全体的な目標を段階的に実装する必要があります。

## 生きた計画と設計決定

* ExecPlans は生きたドキュメントです。重要な設計決定を行う際は、決定とその背後にある考え方の両方を記録するように計画を更新してください。すべての決定を `Decision Log` セクションに記録してください。
* ExecPlans には、`Progress` セクション、`Surprises & Discoveries` セクション、`Decision Log`、`Outcomes & Retrospective` セクションが含まれ、維持される必要があります。これらはオプションではありません。
* オプティマイザーの動作、パフォーマンストレードオフ、予期しないバグ、またはアプローチを形成した逆/非適用セマンティクスを発見した場合は、短い証拠スニペット（テスト出力が理想的）とともに、これらの観察を `Surprises & Discoveries` セクションにキャプチャしてください。
* 実装の途中でコースを変更する場合は、`Decision Log` で理由を文書化し、`Progress` に影響を反映させてください。計画は、あなたのためのチェックリストであると同時に、次の貢献者のためのガイドです。
* 主要なタスクまたは完全な計画の完了時に、達成されたこと、残っていること、学んだ教訓を要約した `Outcomes & Retrospective` エントリを書いてください。

# プロトタイピングマイルストーンと並行実装

より大きな変更のリスクを軽減する場合、明示的なプロトタイピングマイルストーンを含めることは許容され、多くの場合推奨されます。例：実現可能性を検証するために依存関係に低レベルの演算子を追加する、またはオプティマイザーの効果を測定しながら2つの構成順序を探索する。プロトタイプを追加可能でテスト可能に保ちます。スコープを「プロトタイピング」として明確にラベル付けし、実行して結果を観察する方法を説明し、プロトタイプを昇格または破棄する基準を述べてください。

テストを合格させ続ける減算が続く追加のコード変更を優先してください。並行実装（たとえば、大規模な移行中に古いパスと一緒にアダプターを保持する）は、リスクを減らすか、大規模な移行中にテストが合格し続けることを可能にする場合に問題ありません。両方のパスを検証する方法と、テストを使用して一方を安全に廃止する方法を説明してください。複数の新しいライブラリや機能領域で作業する場合は、これらの機能の実現可能性を_相互に独立して_評価するスパイクを作成し、外部ライブラリが期待どおりに動作し、分離して必要な機能を実装することを証明することを検討してください。

## 良い ExecPlan のスケルトン

```md
# <短い、アクション指向の説明>

この ExecPlan は生きたドキュメントです。作業が進むにつれて、`Progress`、`Surprises & Discoveries`、`Decision Log`、`Outcomes & Retrospective` セクションを最新の状態に保つ必要があります。

PLANS.md ファイルがリポジトリにチェックインされている場合は、リポジトリのルートからそのファイルへのパスをここで参照し、このドキュメントが PLANS.md に従って維持される必要があることを記載してください。

## Purpose / Big Picture

この変更後に誰かが得るものと、それが機能しているのをどのように確認できるかを数文で説明します。有効にするユーザーに見える動作を述べてください。

## Progress

チェックボックス付きのリストを使用して、粒度の細かいステップを要約します。すべての停止ポイントをここで文書化する必要があります。部分的に完了したタスクを2つ（「完了」対「残り」）に分割する必要がある場合でも。このセクションは常に作業の実際の現在の状態を反映している必要があります。

- [x] (2025-10-01 13:00Z) 完了したステップの例。
- [ ] 未完了のステップの例。
- [ ] 部分的に完了したステップの例（完了：X、残り：Y）。

タイムスタンプを使用して進捗率を測定します。

## Surprises & Discoveries

実装中に発見された予期しない動作、バグ、最適化、洞察を文書化します。簡潔な証拠を提供してください。

- 観察：…
  証拠：…

## Decision Log

計画に取り組んでいる間に行われたすべての決定を次の形式で記録します：

- 決定：…
  理由：…
  日付/著者：…

## Outcomes & Retrospective

主要なマイルストーンまたは完了時に、成果、ギャップ、学んだ教訓を要約します。元の目的と結果を比較してください。

## Context and Orientation

読者が何も知らないかのように、このタスクに関連する現在の状態を説明します。完全なパスでキーファイルとモジュールに名前を付けます。使用する非明白な用語を定義します。以前の計画を参照しないでください。

## Plan of Work

散文で、編集と追加のシーケンスを説明します。各編集について、ファイルと場所（関数、モジュール）と挿入または変更する内容を指定します。具体的で最小限に保ちます。

## Concrete Steps

実行する正確なコマンドとそれを実行する場所（作業ディレクトリ）を述べます。コマンドが出力を生成する場合は、読者が比較できるように短い期待されるトランスクリプトを表示します。このセクションは作業が進むにつれて更新される必要があります。

## Validation and Acceptance

システムを起動または実行する方法と、何を観察するかを説明します。受け入れを動作として表現し、特定の入力と出力を使用します。テストが関係する場合は、「<プロジェクトのテストコマンド>を実行し、<N>個の合格を期待する。新しいテスト<名前>は変更前に失敗し、変更後に合格する」と言ってください。

## Idempotence and Recovery

ステップを安全に繰り返すことができる場合は、そう言ってください。ステップがリスクがある場合は、安全な再試行またはロールバックパスを提供してください。完了後、環境をクリーンに保ちます。

## Artifacts and Notes

最も重要なトランスクリプト、差分、スニペットをインデントされた例として含めます。成功を証明するものに焦点を当てて、簡潔に保ちます。

## Interfaces and Dependencies

規範的であってください。使用するライブラリ、モジュール、サービスとその理由を名前で指定します。マイルストーンの終わりに存在する必要がある型、トレイト/インターフェース、関数シグネチャを指定します。`crate::module::function` や `package.submodule.Interface` などの安定した名前とパスを優先します。例：

crates/foo/planner.rs で、次を定義します：

    pub trait Planner {
        fn plan(&self, observed: &Observed) -> Vec<Action>;
    }
```

上記のガイダンスに従えば、単一のステートレスエージェント、または人間の初心者が、ExecPlan を上から下まで読んで、機能する観察可能な結果を生成できます。それが基準です：自己完結、自己充足、初心者をガイドし、成果に焦点を当てたものです。

計画を修正する際は、変更が生きたドキュメントセクションを含むすべてのセクションに包括的に反映されていることを確認する必要があり、計画の最後に変更とその理由を説明するメモを書く必要があります。ExecPlans は、何だけでなく、ほぼすべてについてなぜも説明する必要があります。
````
