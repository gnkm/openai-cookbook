# Codexでコードベースを現代化する

## はじめに

Codexは大規模で複雑なコードベースを読み取り、理解し、エンジニアと共に作業を計画し、高品質な変更を生成するように訓練されています。コードの現代化は、その最も一般的で価値のある用途の一つとなっています。この設定では、エンジニアはアーキテクチャとビジネスルールに集中し、Codexが重い作業を担当します：レガシーパターンの翻訳、安全なリファクタリングの提案、システムの進化に合わせたドキュメントとテストの同期維持などです。

このクックブックでは、**OpenAIのCodex CLI**を使用してレガシーリポジトリを現代化する方法を示します。この方法は以下の特徴があります：

* 新しいエンジニアにとって理解しやすい
* アーキテクトとリスクチームによる監査可能
* 他のシステムでもパターンとして再現可能

実行例として、COBOLベースの[投資ポートフォリオシステム](https://github.com/sentientsergio/COBOL-Legacy-Benchmark-Suite/)を使用し、単一のパイロットフローに焦点を当てます。レガシープログラム、オーケストレーション（ジョブ、スケジューラ、スクリプト）、または共有データソースがあるレガシースタック（例：Javaモノリス、PL/SQL）に置き換えることができます。

---

## 高レベル概要

実行計画（略してExecPlan）を中心とした5つの異なるフェーズに分けました。これは、エージェントがシステム変更を実現するために従うことができる設計文書です。

<img src="../../images/code-modernization-phases.png" alt="Code Modernization Phases" width="700"/>

選択したパイロットフローに対して4種類の文書を作成します：

* **pilot_execplan.md** - パイロットを統括するExecPlan。スコープ内容、重要性、実行手順、完了判定基準を回答します。
* **pilot_overview.md** - 関与するレガシープログラム（この例ではCOBOL）、オーケストレーションジョブ（ここではJCL）、データソース、データの流れ、実際のビジネスフローの内容。
* **pilot_design.md** - システムの目標形状：このフローを所有するサービス/モジュール、新しいデータモデル、パブリックAPIまたはバッチエントリポイント。
* **pilot_validation.md** - パリティの証明方法を定義：主要シナリオ、共有入力データセット、レガシーと現代版の並行実行方法、実際の「出力の一致」の意味。

これら4つのファイルは、変更されるコード、新しいシステムの外観、動作が退行していないことを確認する正確な方法を明確にします。

---

## フェーズ0 - AGENTSとPLANSの設定

**目標**：プロセスで人々を圧倒することなく、このリポジトリでの計画の仕組みについてCodexに軽量な契約を与える。

[マルチ時間問題解決のためのPLANS.mdの使用](https://cookbook.openai.com/articles/codex_exec_plans)クックブックからインスピレーションを得て、.agentフォルダに配置されるAGENTS.mdとPLANS.mdファイルを作成します。

* AGENTS.md：リポジトリ用のAGENTS.mdをまだ作成していない場合は、/initコマンドの使用をお勧めします。生成後、AGENTS.mdにPLANS.mdを参照するようエージェントに指示するセクションを追加してください。
* PLANS.md：クックブックで提供されている例を出発点として使用してください

これらは、ExecPlanとは何か、いつ作成または更新するか、どこに存在するか、すべての計画が持つべきセクションについて説明します。

### Codex CLIが役立つ場面
Codexに特定のリポジトリ用のAGENTSやPLANSを調整してもらいたい場合は、以下を実行できます：

```md
ディレクトリ構造を読み取り、.agent/AGENTS.mdと.agent/PLANS.mdを改良して、ここでCOBOL現代化作業を計画する方法について明確で意見のある標準にしてください。ExecPlanの骨格は保持しつつ、1つか2つの具体例を追加してください。
```

---

## フェーズ1 - パイロットを選択し、最初のExecPlanを作成

**目標**：現実的だが境界が明確な1つのパイロットフローについて合意し、フェーズ1の計画を単一のExecPlanファイルに記録する。

**主要成果物**：pilot_execplan.md

### 1.1 パイロットフローの選択
パイロットに使用するフローが決まっていない場合は、Codexに提案を求めることができます。リポジトリルートからの例のプロンプト：

```md
このリポジトリを調べて、現実的だが境界が明確な現代化のための1つまたは2つの候補パイロットフローを提案してください。
各候補について、以下をリストしてください：
- 関与するCOBOLプログラムとコピーブック
- 関与するJCLメンバー
- 平易な言葉でのビジネスシナリオ
- 最初のパイロットとして使用すべきフローの明確な推奨で終える
```

この場合、レポートフローをパイロットとして選択します。

<img src="../../images/pilot-candidate.png" alt="Pilot Candidate Flow" width="700"/>

### 1.2 CodexにパイロットExecPlanの作成を依頼

```md
.agent/PLANS.mdに従ってpilot_execplan.mdを作成してください。日次レポートフローにスコープを設定してください。計画は、この1つのフローに対する4つの成果をカバーする必要があります：
- インベントリと図表
- 現代化技術レポートの内容
- ターゲット設計と仕様
- パリティのテスト計画
ExecPlanの骨格を使用し、実際のCOBOLとJCLファイルへの具体的な参照で埋めてください。
```

この計画が、すべてのパイロット作業の「ホームベース」になります。

---

## フェーズ2 - インベントリと発見

**目標**：パイロットフローが現在実際に行っていることを記録する：プログラム、ジョブ、データフロー、ビジネスルール。エンジニアがレガシーコードのすべての行を読むことなく変更について推論できるようにする。

**主要成果物**：pilot_reporting_overview.md

**エンジニアが集中できる場所**：

* 本当に本番環境で実行されるジョブの確認
* Codexがコードから推測できないギャップの埋め合わせ（SLA、運用コンテキスト、所有者）
* 図表と説明の妥当性チェック

### 2.1 Codexに概要のドラフト作成を依頼
```md
pilot_execplan.mdを使用してパイロットフローを特定し、「パイロットのインベントリ」と「パイロットの現代化技術レポート」の2つのトップレベルセクションでpilot_reporting_overview.mdを作成または更新してください。

インベントリセクションには以下を含めてください：
1. 関与するCOBOLプログラムとコピーブック、該当する場合はバッチ、オンライン、ユーティリティとしてグループ化
2. これらのプログラムを呼び出すJCLジョブとステップ
3. 読み書きするデータセットまたはテーブル
4. ジョブとデータフローのシーケンスを示すシンプルなテキスト図

現代化技術レポートセクションには以下を記述してください：
1. このフローのビジネスシナリオを平易な言葉で
2. フロー内の各COBOLプログラムの詳細な動作
3. 主要ファイルとテーブルのデータモデル（フィールド名と意味を含む）
4. 日付処理、丸め処理、特別なエラーコード、複雑な条件などの既知の技術的リスク
```

この文書は、エンジニアがすべてのコードを読むことなく、パイロットの形状と動作を理解するのに役立ちます。

pilot_reporting_overview.mdのフロー図の例

<img src="../../images/pilot-flow-diagram.png" alt="Pilot Flow Diagram" width="700"/>

### 2.2 ExecPlanの更新

概要が存在したら、Codexに計画を整合させるよう依頼します

```md
新しいpilot_reporting_overview.mdファイルを反映するようにpilot_execplan.mdを更新してください。
- 進捗で、インベントリとMTRセクションをドラフト済みとしてマークしてください。
- 注目すべき発見があれば、「驚きと発見」と「決定ログ」に追加してください。
- ExecPlanをリポジトリに新しい人にとって読みやすく保ってください。
```

フェーズ2の終了時には、システムインベントリレポートと現代化技術レポートの両方の役割を果たす単一のパイロット概要文書ができあがります。

---

## フェーズ3 - 設計、仕様、検証計画

**目標**

* パイロットフローの現代版がどのような外観であるべきかを決定する
* ターゲットサービスとデータモデルを記述する
* テストと並行実行を通じてパリティを証明する方法を定義する

このフェーズの終了時には、何を構築するかと、それが機能することをどのように証明するかを決定します。

**主要成果物**

* pilot_reporting_design.md
* pilot_reporting_validation.md
* modern/openapi/pilot.yaml
* modern/tests/pilot_parity_test.py

### 3.1 ターゲット設計文書

```md
pilot_reporting_overview.mdに基づいて、以下のセクションでpilot_reporting_design.mdをドラフトしてください：

# ターゲットサービス設計
- 現代アーキテクチャでこのパイロットフローを所有するサービスまたはモジュール。
- バッチジョブ、REST API、イベントリスナー、またはそれらの組み合わせとして実装されるかどうか。
- より広いドメインモデルにどのように適合するか。

# ターゲットデータモデル
- 現在のファイルまたはDB2テーブルを置き換える提案されたデータベーステーブルと列。
- キー、関係、および派生フィールド。
- パックされた小数点やEBCDICフィールドなどのレガシーエンコーディングがどのように表現されるかについてのメモ。

# API設計概要
- ユーザーまたはシステムが呼び出すメイン操作。
- 各エンドポイントまたはイベントの短い説明。
- 完全なスキーマが存在するmodern/openapi/pilot.yamlへのポインタ。
```

### 3.2 API仕様

パイロットフローの外部動作をOpenAPIファイルに記録し、現代システムが明確で言語に依存しない契約を持つようにします。この仕様は実装、テスト生成、将来の統合のアンカーとなり、Codexがコードとテストを足場として構築するための具体的なものを提供します。

```md
pilot_reporting_design.mdを使用して、このパイロットの外部APIを記述するOpenAPIファイルをmodern/openapi/pilot.yamlにドラフトしてください。以下を含めてください：
- メインエンドポイントまたは管理フックのパスと操作
- 各操作のリクエストとレスポンススキーマ
- ターゲットデータモデルと整合するフィールドタイプと制約
```

出力例：

<img src="../../images/pilot-yaml.png" alt="Pilot Yaml" width="700"/>

### 3.3 検証とテスト計画

```md
3つのセクションでpilot_reporting_validation.mdを作成または更新してください：

# テスト計画
- 少なくとも1つのハッピーパスといくつかのエッジケースを含む主要シナリオ。
- 各シナリオでキャプチャする入力と出力。

# パリティと比較戦略
- 同じ入力データでレガシーCOBOLフローと現代実装をどのように実行するか。
- 比較される出力（ファイル、テーブル、ログ）。
- 差異がどのように検出され、トリアージされるか。

# テスト足場
- modern/tests/pilot_parity_test.pyテストファイルについてのメモ（実行方法を含む）。
- 現代実装が存在した後に埋める必要があるもの。
```

次に、Codexにテストの足場を作成するよう依頼します：

```md
pilot_reporting_validation.mdを使用して、modern/tests/pilot_parity_test.pyに初期テストファイルを作成してください。

テスト計画のシナリオを参照するプレースホルダーアサーションとコメントを含めますが、現代実装がまだ存在しないことを前提としてください。
```

### 3.4 ExecPlanの更新

```md
作業計画、具体的ステップ、検証と受け入れが以下を明示的に参照するようにpilot_execplan.mdを更新してください：
1. pilot_reporting_overview.md
2. pilot_reporting_design.md
3. pilot_reporting_validation.md
4. modern/openapi/pilot.yaml
5. modern/tests/pilot_parity_test.py
```

フェーズ3の終了時には、明確な設計、機械可読な仕様、パリティを証明する方法を記述するテスト計画/足場ができあがります。

---

## フェーズ4 - 実装と比較

**目標：** 現代パイロットを実装し、COBOLバージョンと並行して実行し、計画されたシナリオで出力が一致することを示す。

**主要成果物**

* modern/<stack>/pilot以下のコード（例：modern/java/pilot）
* modern/tests/pilot_parity_test.pyの完成したテスト
* 実際の並行実行ステップを記述するpilot_reporting_validation.mdの更新されたセクション

### 4.1 現代コードの最初のドラフトを生成

```md
pilot_reporting_design.mdとpilot_reporting_overview.mdにリストされたCOBOLプログラムを使用して、modern/<stack>/pilot以下に初期実装コードを生成してください：
- 主要レコードとテーブルのドメインモデルとデータベースエンティティを定義。
- COBOLパラグラフからの動作を保持しながら、サービスクラスでコアビジネスロジックを実装。
- 元のCOBOLパラグラフとコピーブックを参照するコメントを追加。
- これをエンジニアがレビューする最初のドラフトとして扱う。
```

異なるモジュールに焦点を当てて、これを数回実行できます。

### 4.2 パリティテストの配線

```md
modern/tests/pilot_parity_test.pyを拡張して、以下を行うようにしてください：
- COBOL用のラッパーまたはコマンド（例：テストハーネスでJCLを実行するスクリプト）を使用してレガシーパイロットフローを呼び出す。
- APIまたはバッチエントリポイントを通じて新しい実装を呼び出す。
- pilot_reporting_validation.mdの「パリティと比較戦略」に従って出力を比較する。
```

### 4.3 並行実行ステップの文書化

別のparallel_run_pilot.mdではなく、検証文書を再利用します：

```md
pilot_reporting_validation.mdの「パリティと比較戦略」セクションを更新して、以下を行う明確で順序付けられたコマンドリストを含めてください：
- 入力データセットの準備またはロード
- そのデータでCOBOLパイロットフローを実行
- 同じデータで現代パイロットフローを実行
- 出力を比較し、結果を解釈
- 出力の正確なパスと成功の外観の短い説明を含める
```

### 4.4 （必要に応じて）反復修正にCodexを使用

テストが失敗したり動作が異なったりする場合は、短いループで作業します：

```md
modern/tests/pilot_parity_test.pyからの失敗テストと関連するCOBOLおよび現代コードがあります。出力が異なる理由を説明し、COBOLの動作に合わせる現代実装への最小の変更を提案してください。更新されたコードと必要なテスト調整を示してください。
```

意味のある作業の塊を完了するたびに、CodexにExecPlanの更新を依頼します：

```md
進捗、決定ログ、成果がパイロットの最新のコード、テスト、検証結果を反映するようにpilot_execplan.mdを更新してください。
```

ExecPlanの「進捗」と「成果」セクションが以下のような内容で更新されることがわかります：

```md
進捗  
- [x] インベントリと図表のドラフト作成（`pilot_reporting_overview.md`と`system-architecture.md`のサポートメモ）。  
- [x] 現代化技術レポートのドラフト作成（`pilot_reporting_overview.md`のMTRセクション）。  
- [x] ターゲット設計仕様のドラフト作成（`pilot_reporting_design.md`と`modern/openapi/pilot.yaml`）。  
- [x] パリティテスト計画と足場の文書化（`pilot_reporting_validation.md`と`modern/tests/pilot_parity_test.py`）。

成果  
- `pilot_reporting_overview.md`、`pilot_reporting_design.md`、`pilot_reporting_validation.md`が、エンドツーエンドの物語（インベントリ、設計、検証）を提供。  
- `modern/openapi/pilot.yaml`がAPIサーフェスを記述し、`modern/python/pilot/{models,repositories,services}.py`がドラフト実装を保持。  
- `modern/tests/pilot_parity_test.py`が検証戦略に合わせたプレースホルダーとヘルパーを使用してパリティフローを実行。  
- 残りの作業は、運用テスト付録の更新とサービスの実際のランタイムへの配線に限定。
```

---

## フェーズ5 - パイロットをスケーラブルなモーションに変換

**目標：** 他のフローのための再利用可能なテンプレートと、このリポジトリでCodexを使用するための短いガイドを提供する。

**主要成果物**

* template_modernization_execplan.md
* how_to_use_codex_for_cobol_modernization.md

### 6.1 テンプレートExecPlan

```md
作成したパイロットファイルを確認してください：
1. pilot_reporting_overview.md
2. pilot_reporting_design.md
3. pilot_reporting_validation.md
4. pilot_execplan.md

別のフローを現代化する際にチームがコピーできるtemplate_modernization_execplan.mdを作成してください。以下を満たす必要があります：
1. .agent/PLANS.mdに従う
2. 「概要」、「インベントリ」、「現代化技術レポート」、「ターゲット設計」、「検証計画」のプレースホルダーを含む
3. 同様のパターンを前提とする：概要文書、設計文書、検証文書、OpenAPI仕様、テスト。
```

### 6.2 ハウツーガイド

```md
同じパイロットファイルを使用して、how_to_use_codex_for_cobol_modernization.mdを書いてください：
1. 高レベルでのフェーズの説明（パイロットの選択、インベントリと発見、設計と仕様、実装と検証、ファクトリーパターン）。
2. 各フェーズで、コーディングエージェントがどこで役立つかをリストし、関連ファイルと例のプロンプトを指し示す。
```

---

## まとめ

任意のパイロットでこのクックブックの手順に従えば、大まかに以下のようなフォルダレイアウトになるはずです：ExecPlan、3つのパイロット文書、OpenAPI仕様、パイロットモジュール、パリティテスト。より多くの構造のために、追加のパイロットとテンプレートサブフォルダでマークダウンファイルをさらに整理できます。

<img src="../../images/pilot-folder-structure.png" alt="Pilot Folder Structure" width="700"/>

モジュール（models.py、repositories.py、services.py）は開始するための最初のドラフトビルディングブロックなので、modern/python/pilotにはまだ実行可能なエントリポイントがないことに気づくでしょう。ローカルで実験したい場合は、2つのオプションがあります：

* インタラクティブシェルまたは小さなスクリプトを使用
* リポジトリとサービスを結び付ける独自のランナー（例：modern/python/pilot/main.py）を作成

このクックブックでは実行例としてCOBOLパイロットフローを使用していますが、同じパターンは非常に異なる種類のリファクタリングでも現れます。例えば、ある顧客はCodexを使用して大規模なモノレポを移行し、数百のJiraチケットを供給し、Codexにより高リスクな作業をフラグ付けし、横断的な依存関係を表面化し、コード変更をドラフトし、別のバリデーターがレビューとマージを行いました。

COBOLリポジトリの現代化は人気のあるケースの一つに過ぎませんが、同じアプローチは任意のレガシースタックや大規模移行に適用されます：「コードベースを現代化する」を一連の小さくテスト可能なステップ（ExecPlan、少数の文書、パリティファーストの実装）に変換します。Codexは古いパターンの理解、候補移行の生成、パリティの調整という地道な作業を処理し、あなたとあなたのチームはアーキテクチャとトレードオフに集中し続け、前進させることを決定したすべてのシステムで現代化をより速く、より安全で、再現可能にします。